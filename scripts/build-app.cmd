rustc --print sysroot --target thumbv7m-none-eabi >tmprustroot.txt
goto :EOF

::  Windows script to build Rust application hosted on Mynewt OS

@echo "----- Building Rust app and Mynewt OS..."

::  Rust build profile: debug or release
::  set rust_build_profile=debug
set rust_build_profile=release

::  Location of the compiled ROM image.  We will remove this to force relinking the Rust app with Mynewt OS.
set app_build=%cd%\bin\targets\bluepill_my_sensor\app\apps\my_sensor_app\my_sensor_app.elf

::  Location of the compiled Rust app and external libraries.  The Rust compiler generates a *.rlib archive for the Rust app and each external Rust library here.
set rust_build_dir=%cd%\target\thumbv7m-none-eabi\%rust_build_profile%\deps

::  Location of the libs\rust_app stub library built by Mynewt.  We will replace this stub by the Rust app and external libraries.
set rust_app_dir=%cd%\bin\targets\bluepill_my_sensor\app\libs\rust_app
set rust_app_dest=%rust_app_dir%\libs_rust_app.a

::  Location of the libs\rust_libcore stub library built by Mynewt.  We will replace this stub by the Rust core library libcore.
set rust_libcore_dir=%cd%\bin\targets\bluepill_my_sensor\app\libs\rust_libcore
set rust_libcore_dest=%rust_libcore_dir%\libs_rust_libcore.a

if %rust_build_profile%==release (
    ::  Build for release
    set rust_build_options=--release 
) else (
    ::  Build for debug
    set rust_build_options= 
)

::  If this is the very first build, do the Mynewt build to generate the rust_app and rust_libcore stubs.  This build will not link successfully but it's OK.
if not exist %rust_app_dest% (
    @echo "----- Build Mynewt stubs for Rust app and Rust libcore (ignore error)"
    newt\newt.exe build bluepill_my_sensor
)

::  Delete the compiled ROM image to force the Mynewt build to relink the Rust app with Mynewt OS.
if exist %app_build% (
    del %app_build%
)

::  Delete the compiled Rust app to force the Rust build to relink the Rust app.  Sometimes there are multiple copies of the compiled app, this deletes all copies.
for %%f in (%rust_build_dir%\libapp*.rlib) do del %%f

::  TODO: Expand Rust macros
rustup default nightly
pushd rust\mynewt && cargo rustc -v %rust_build_options% -- -Z unstable-options --pretty expanded > ..\..\logs\libmynewt-expanded.rs && popd
pushd rust\app    && cargo rustc -v %rust_build_options% -- -Z unstable-options --pretty expanded > ..\..\logs\libapp-expanded.rs    && popd

::  Build the Rust app in "src" folder.
@echo "----- Build Rust app"
cargo build -v %rust_build_options%
if errorlevel 1 goto :EOF

::  Export the metadata for the Rust build.
cargo metadata --format-version 1 >logs\libapp.json
if errorlevel 1 goto :EOF

::  Create rustlib, the library that contains the compiled Rust app and its dependencies (except libcore).  Create in temp folder named "tmprustlib"
@echo "----- Consolidate Rust app and external libraries"
if exist tmprustlib (
    rd /s tmprustlib
)
if not exist tmprustlib (
    mkdir tmprustlib
)
pushd tmprustlib

::  Extract the object (*.o) files in the compiled Rust output (*.rlib).
for %%f in (%rust_build_dir%\*.rlib) do arm-none-eabi-ar x %%f

::  Archive the object (*.o) files into rustlib.a.
@echo "arm-none-eabi-ar r rustlib.a *.o"
arm-none-eabi-ar r rustlib.a *.o

::  Overwrite libs_rust_app.a in the Mynewt build by rustlib.a.  libs_rust_app.a was originally created from libs\rust_app.
if not exist %rust_app_dir% (
    mkdir -p %rust_app_dir%
)
copy rustlib.a %rust_app_dest%
:: TODO
:: touch %rust_app_dest%

::  Dump the ELF and disassembly for the compiled Rust application and libraries (except libcore)
arm-none-eabi-objdump -t -S            --line-numbers --wide rustlib.a >..\logs\rustlib.S 2>&1
arm-none-eabi-objdump -t -S --demangle --line-numbers --wide rustlib.a >..\logs\rustlib-demangle.S 2>&1

::  Return to the parent directory.
popd

::  Copy Rust libcore to libs_rust_libcore.a, which is originally generated by libs\rust_libcore.
@echo "----- Copy Rust libcore"
::  Get the Rust compiler sysroot e.g. \Users\Luppy\.rustup\toolchains\nightly-2019-05-22-x86_64-apple-darwin
::  TODO
set rust_sysroot=`rustc --print sysroot --target thumbv7m-none-eabi`
::  Get the libcore file in the sysroot.
set rust_libcore_src=
::  Copy libcore to the Mynewt build folder.
if not exist %rust_libcore_dir% (
    mkdir %rust_libcore_dir%
)
if exist %rust_libcore_dest% (
    del %rust_libcore_dest%
)
for %%f in (%rust_sysroot%\lib\rustlib\thumbv7m-none-eabi\lib\libcore-*.rlib) do copy %%f %rust_libcore_dest%
::  TODO
::  touch %rust_libcore_dest%

::  Dump the ELF and disassembly for the compiled Rust application.
arm-none-eabi-readelf -a --wide target\thumbv7m-none-eabi\%rust_build_profile%\libapp.rlib >logs\libapp.elf 2>&1
arm-none-eabi-objdump -t -S            --line-numbers --wide target\thumbv7m-none-eabi\%rust_build_profile%\libapp.rlib >logs\libapp.S 2>&1
arm-none-eabi-objdump -t -S --demangle --line-numbers --wide target\thumbv7m-none-eabi\%rust_build_profile%\libapp.rlib >logs\libapp-demangle.S 2>&1

::  Run the Mynewt build, which will link with the Rust app, Rust libraries and libcore.
::  For verbose build: newt build -v -p bluepill_my_sensor
@echo "----- Build and link Mynewt with Rust app"
newt\newt.exe build bluepill_my_sensor
if errorlevel 1 goto :EOF

::  Display the image size.
newt\newt.exe size -v bluepill_my_sensor
if errorlevel 1 goto :EOF
