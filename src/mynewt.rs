//! Mynewt API for Rust. Contains Rust bindings for Mynewt API for C, generated by `bindgen`.
//! Also includes safe versions of Mynewt APIs created specially for Rust.

#[macro_use]            //  Allow macros from Rust module `macros`
pub mod macros;         //  Export `macros.rs` as Rust module `macros`. Contains Mynewt macros.

/// `encoding`: Mynewt Encoding API
pub mod encoding;   //  Export folder `encoding` as Rust module `mynewt::encoding`

/// `kernel`: Mynewt Kernel API
pub mod kernel;     //  Export folder `kernel` as Rust module `mynewt::kernel`

/// `hw`: Mynewt Hardware API
pub mod hw;         //  Export folder `hw` as Rust module `mynewt::hw`

/// `libs`: Mynewt Custom API
pub mod libs;       //  Export folder `libs` as Rust module `mynewt::libs`

/// TODO: Defined in repos/apache-mynewt-core/net/oic/src/api/oc_rep.c
#[link(name = "net_oic")]
extern {
    pub static mut g_encoder: encoding::tinycbor::CborEncoder;
    pub static mut root_map:  encoding::tinycbor::CborEncoder;
}

/// Return type and error codes for Mynewt API
pub mod result {
    use super::kernel::os;

    /// Common return type for Mynewt API.  If no error, returns `Ok(val)` where val has type T.
    /// Upon error, returns `Err(err)` where err is the MynewtError error code.
    pub type MynewtResult<T> = ::core::result::Result<T, MynewtError>;

    /// Error codes for Mynewt API
    #[repr(i32)]
    #[derive(Debug, PartialEq)]
    pub enum MynewtError {
        /// Error code 0 means no error.
        SYS_EOK         = os::SYS_EOK as i32,
        SYS_ENOMEM      = os::SYS_ENOMEM,
        SYS_EINVAL      = os::SYS_EINVAL,
        SYS_ETIMEOUT    = os::SYS_ETIMEOUT,
        SYS_ENOENT      = os::SYS_ENOENT,
        SYS_EIO         = os::SYS_EIO,
        SYS_EAGAIN      = os::SYS_EAGAIN,
        SYS_EACCES      = os::SYS_EACCES,
        SYS_EBUSY       = os::SYS_EBUSY,
        SYS_ENODEV      = os::SYS_ENODEV,
        SYS_ERANGE      = os::SYS_ERANGE,
        SYS_EALREADY    = os::SYS_EALREADY,
        SYS_ENOTSUP     = os::SYS_ENOTSUP,
        SYS_EUNKNOWN    = os::SYS_EUNKNOWN,
        SYS_EREMOTEIO   = os::SYS_EREMOTEIO,
        SYS_EDONE       = os::SYS_EDONE,
        SYS_EPERUSER    = os::SYS_EPERUSER,
    }

    /// Cast `MynewtError` to `i32`
    impl From<MynewtError> for i32 {
        fn from(err: MynewtError) -> Self {
            err as i32
        }
    }

    /// Cast `i32` to `MynewtError`
    impl From<i32> for MynewtError {
        fn from(num: i32) -> Self {
            unsafe { 
                ::core::mem::transmute::
                    <i32, MynewtError>
                    (num)
            }  
        }
    }
}

pub mod types {
//! From https://docs.rs/crate/cty/0.2.0/source/src/lib.rs
//! Type aliases to C types like c_int for use with bindgen
//!
//! # MSRV
//!
//! This crate is guaranteed to compile on stable Rust 1.30.0 and up. It *might* compile with older
//! versions but that may change in any new patch release.

#![allow(non_camel_case_types)]
#![deny(warnings)]
#![no_std]

// AD = Architecture dependent
pub use ad::*;
// OD = OS dependent
pub use od::*;
// PWD = Pointer Width Dependent
pub use pwd::*;

#[cfg(any(target_arch = "aarch64",
          target_arch = "arm",
          target_arch = "asmjs",
          target_arch = "wasm32",
          target_arch = "wasm64",
          target_arch = "powerpc",
          target_arch = "powerpc64",
          target_arch = "s390x"))]
mod ad {
    pub type c_char = super::c_uchar;

    pub type c_int = i32;
    pub type c_uint = u32;
}

#[cfg(any(target_arch = "mips",
          target_arch = "mips64",
          target_arch = "sparc64",
          target_arch = "x86",
          target_arch = "x86_64",
          target_arch = "nvptx",
          target_arch = "nvptx64"))]
mod ad {
    pub type c_char = super::c_schar;

    pub type c_int = i32;
    pub type c_uint = u32;
}

#[cfg(target_arch = "msp430")]
mod ad {
    pub type c_char = super::c_uchar;

    pub type c_int = i16;
    pub type c_uint = u16;
}

// NOTE c_{,u}long definitions come from libc v0.2.3
#[cfg(not(any(windows,
              target_os = "redox",
              target_os = "solaris")))]
mod od {
    #[cfg(any(target_pointer_width = "16",
              target_pointer_width = "32"))]
    pub type c_long = i32;
    #[cfg(any(target_pointer_width = "16",
              target_pointer_width = "32"))]
    pub type c_ulong = u32;

    #[cfg(target_pointer_width = "64")]
    pub type c_long = i64;
    #[cfg(target_pointer_width = "64")]
    pub type c_ulong = u64;
}

#[cfg(windows)]
mod od {
    pub type c_long = i32;
    pub type c_ulong = u32;
}

#[cfg(any(target_os = "redox",
          target_os = "solaris"))]
mod od {
    pub type c_long = i64;
    pub type c_ulong = u64;
}

#[cfg(target_pointer_width = "32")]
mod pwd {}

#[cfg(target_pointer_width = "64")]
mod pwd {}

pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;

pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;

pub type c_schar = i8;
pub type c_short = i16;
pub type c_longlong = i64;

pub type c_uchar = u8;
pub type c_ushort = u16;
pub type c_ulonglong = u64;

pub type c_float = f32;
pub type c_double = f64;

pub type intmax_t = i64;
pub type uintmax_t = u64;

pub type size_t = usize;
pub type ptrdiff_t = isize;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type ssize_t = isize;

pub type c_void = core::ffi::c_void;    
}