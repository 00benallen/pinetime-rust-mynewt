//! Mynewt API for Rust. Contains Rust bindings for Mynewt API for C, generated by `bindgen`.
//! Also includes safe versions of Mynewt APIs created specially for Rust.

#![no_std]                        //  Don't link with standard Rust library, which is not compatible with embedded systems
#![feature(const_transmute)]     //  Allow `transmute` for initialising Mynewt structs

#[macro_use]        //  Allow macros from Rust module `macros`
pub mod macros;     //  Export `macros.rs` as Rust module `macros`. Contains Mynewt macros.
#[allow(dead_code)]               //  Suppress warnings of unused constants and vars
#[allow(non_camel_case_types)]    //  Allow type names to have non-camel case
#[allow(non_upper_case_globals)]  //  Allow globals to have lowercase letters
pub mod encoding;   //  Mynewt Encoding API. Export folder `encoding` as Rust module `mynewt::encoding`
#[allow(dead_code)]               //  Suppress warnings of unused constants and vars
#[allow(non_camel_case_types)]    //  Allow type names to have non-camel case
#[allow(non_upper_case_globals)]  //  Allow globals to have lowercase letters
pub mod kernel;     //  Mynewt Kernel API. Export folder `kernel` as Rust module `mynewt::kernel`
#[allow(dead_code)]               //  Suppress warnings of unused constants and vars
#[allow(non_camel_case_types)]    //  Allow type names to have non-camel case
#[allow(non_upper_case_globals)]  //  Allow globals to have lowercase letters
pub mod hw;         //  Mynewt Hardware API. Export folder `hw` as Rust module `mynewt::hw`
#[allow(dead_code)]               //  Suppress warnings of unused constants and vars
#[allow(non_camel_case_types)]    //  Allow type names to have non-camel case
#[allow(non_upper_case_globals)]  //  Allow globals to have lowercase letters
pub mod libs;       //  Mynewt Custom API. Export folder `libs` as Rust module `mynewt::libs`

/// TODO: Defined in repos/apache-mynewt-core/net/oic/src/api/oc_rep.c
#[link(name = "net_oic")]
extern {
    /// Global CBOR encoder
    pub static mut g_encoder: encoding::tinycbor::CborEncoder;
    /// Global CBOR root map
    pub static mut root_map:  encoding::tinycbor::CborEncoder;
}

/// Return type and error codes for Mynewt API
pub mod result {
    use super::kernel::os;

    /// Common return type for Mynewt API.  If no error, returns `Ok(val)` where val has type T.
    /// Upon error, returns `Err(err)` where err is the MynewtError error code.
    pub type MynewtResult<T> = ::core::result::Result<T, MynewtError>;

    /// Error codes for Mynewt API
    #[repr(i32)]
    #[derive(Debug, PartialEq)]
    #[allow(non_camel_case_types)]    //  Allow type names to have non-camel case
    pub enum MynewtError {
        /// Error code 0 means no error.
        SYS_EOK         = os::SYS_EOK as i32,
        SYS_ENOMEM      = os::SYS_ENOMEM,
        SYS_EINVAL      = os::SYS_EINVAL,
        SYS_ETIMEOUT    = os::SYS_ETIMEOUT,
        SYS_ENOENT      = os::SYS_ENOENT,
        SYS_EIO         = os::SYS_EIO,
        SYS_EAGAIN      = os::SYS_EAGAIN,
        SYS_EACCES      = os::SYS_EACCES,
        SYS_EBUSY       = os::SYS_EBUSY,
        SYS_ENODEV      = os::SYS_ENODEV,
        SYS_ERANGE      = os::SYS_ERANGE,
        SYS_EALREADY    = os::SYS_EALREADY,
        SYS_ENOTSUP     = os::SYS_ENOTSUP,
        SYS_EUNKNOWN    = os::SYS_EUNKNOWN,
        SYS_EREMOTEIO   = os::SYS_EREMOTEIO,
        SYS_EDONE       = os::SYS_EDONE,
        SYS_EPERUSER    = os::SYS_EPERUSER,
    }

    /// Cast `MynewtError` to `i32`
    impl From<MynewtError> for i32 {
        /// Cast `MynewtError` to `i32`
        fn from(err: MynewtError) -> Self {
            err as i32
        }
    }

    /// Cast `i32` to `MynewtError`
    impl From<i32> for MynewtError {
        /// Cast `i32` to `MynewtError`
        fn from(num: i32) -> Self {
            unsafe { 
                ::core::mem::transmute::
                    <i32, MynewtError>
                    (num)
            }  
        }
    }
}

/// Represents a null-terminated byte string, suitable for passing to Mynewt APIs as `* const char`
pub struct Strn {
    /// Byte string terminated with null
    pub bytestr: &'static [u8]
}

impl Strn {
    /// Create a new byte string. Fail if the last byte is not zero.
    /// ```
    /// Strn::new(b"network\0")
    /// strn!("network")
    /// ```
    pub fn new(bs: &'static [u8]) -> Strn {
        //  Last byte must be 0.
        assert_eq!(bs.last(), Some(&0u8));
        let res = Strn { bytestr: bs };
        res
    }

    /// Return the byte string as a null-terminated `* const char` C-style string.
    /// Fail if the last byte is not zero.
    pub fn as_cstr(self) -> *const ::cty::c_char {
        //  Last byte must be 0.
        let bs: &'static [u8] = self.bytestr;
        assert_eq!(bs.last(), Some(&0u8));
        bs.as_ptr() as *const ::cty::c_char
    }

    /// Return the byte string.
    /// Fail if the last byte is not zero.
    pub fn as_bytestr(self) -> &'static [u8] {
        //  Last byte must be 0.
        let bs: &'static [u8] = self.bytestr;
        assert_eq!(bs.last(), Some(&0u8));
        &bs
    }

    /// Fail if the last byte is not zero.
    pub fn validate(self) {
        //  Last byte must be 0.
        let bs = &self.bytestr;
        assert_eq!(bs.last(), Some(&0u8));
    }

    /// Fail if the last byte is not zero.
    pub fn validate_bytestr(bs: &'static [u8]) {
        //  Last byte must be 0.
        assert_eq!(bs.last(), Some(&0u8));
    }
}

pub type Out<T> = &'static mut T;
pub type Ptr = *mut ::cty::c_void;
pub const NULL: Ptr = 0 as Ptr;
