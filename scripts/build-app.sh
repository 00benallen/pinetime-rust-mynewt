#!/usr/bin/env bash
#  Build Rust application hosted on Mynewt OS

set -e  #  Exit when any command fails.
set -x  #  Echo all commands.

#  Delete the compiled image so that the build script will relink the Rust app with the C libraries.
app_build=bin/targets/bluepill_my_sensor/app/apps/my_sensor_app/my_sensor_app.elf
if [ -e $app_build ]; then
    rm $app_build
fi

#  Build the Rust app in "src" folder.
set +x ; echo ; echo "----- Build Rust app" ; set -x
cargo build -v

#  Export the metadata for the Rust build.
cargo metadata --format-version 1 >logs/libmylib.json

#  Create rustlib, the library that contains the compiled Rust app and its dependencies (except libcore).  Create in temp folder named "tmprustlib"
set +x ; echo ; echo "----- Consolidate Rust app and external libraries" ; set -x
if [ -d tmprustlib ]; then
    rm -r tmprustlib
fi
if [ ! -d tmprustlib ]; then
    mkdir tmprustlib
fi
pushd tmprustlib

#  Extract the object (*.o) files in the compiled Rust output (*.rlib).
set +x
rust_build=../target/thumbv7m-none-eabi/debug/deps/*.rlib
for f in $rust_build
do
    echo "arm-none-eabi-ar x $f"
    arm-none-eabi-ar x $f
done

#  Archive the object (*.o) files into rustlib.a.
echo "arm-none-eabi-ar r rustlib.a *.o"
arm-none-eabi-ar r rustlib.a *.o
set -x

#  Overwrite libs_rust_app.a in the Mynewt build by rustlib.a.  libs_rust_app.a was originally created from libs/rust_app.
rust_app_dir=../bin/targets/bluepill_my_sensor/app/libs/rust_app
rust_app_dest=$rust_app_dir/libs_rust_app.a
if [ ! -d $rust_app_dir ]; then
    mkdir -p $rust_app_dir
fi
cp rustlib.a $rust_app_dest
touch $rust_app_dest

#  Dump the ELF and disassembly for the compiled Rust application and libraries (except libcore)
arm-none-eabi-objdump -t -S            --line-numbers --wide rustlib.a >../logs/rustlib.S 2>&1
arm-none-eabi-objdump -t -S --demangle --line-numbers --wide rustlib.a >../logs/rustlib-demangle.S 2>&1

popd

#  Copy Rust libcore to libs_rust_libcore.a, which is originally generated by libs/rust_libcore.
set +x ; echo ; echo "----- Copy Rust libcore" ; set -x
rust_libcore_dir=bin/targets/bluepill_my_sensor/app/libs/rust_libcore
rust_libcore_dest=$rust_libcore_dir/libs_rust_libcore.a
#  Get the Rust compiler sysroot e.g. /Users/Luppy/.rustup/toolchains/nightly-2019-05-22-x86_64-apple-darwin
rust_sysroot=`rustc --print sysroot --target thumbv7m-none-eabi`
#  Get the libcore file in the sysroot.
rust_libcore_src=$rust_sysroot/lib/rustlib/thumbv7m-none-eabi/lib/libcore-*.rlib
#  Copy libcore to the Mynewt build folder.
if [ ! -d $rust_libcore_dir ]; then
    mkdir -p $rust_libcore_dir
fi
if [ -e $rust_libcore_dest ]; then
    rm $rust_libcore_dest
fi
for f in $rust_libcore_src
do
    cp $f $rust_libcore_dest
    touch $rust_libcore_dest
done

#  Dump the ELF and disassembly for the compiled Rust application.
set +e
arm-none-eabi-readelf -a --wide target/thumbv7m-none-eabi/debug/libmylib.rlib >logs/libmylib.elf 2>&1
arm-none-eabi-objdump -t -S            --line-numbers --wide target/thumbv7m-none-eabi/debug/libmylib.rlib >logs/libmylib.S 2>&1
arm-none-eabi-objdump -t -S --demangle --line-numbers --wide target/thumbv7m-none-eabi/debug/libmylib.rlib >logs/libmylib-demangle.S 2>&1
set -e

#  Run the Mynewt build, which will link with the Rust app, Rust libraries and libcore.
#  For verbose build: newt build -v -p bluepill_my_sensor
set +x ; echo ; echo "----- Build and link Mynewt with Rust app (Rebuild if it fails)" ; set -x
newt build bluepill_my_sensor

#  Display the image size.
newt size -v bluepill_my_sensor
