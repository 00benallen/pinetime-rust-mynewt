/* automatically generated by rust-bindgen */

pub const __STDC__: u32 = 1;
pub const __STDC_VERSION__: u32 = 201112;
pub const __STDC_UTF_16__: u32 = 1;
pub const __STDC_UTF_32__: u32 = 1;
pub const __STDC_HOSTED__: u32 = 1;
pub const __GNUC__: u32 = 7;
pub const __GNUC_MINOR__: u32 = 3;
pub const __GNUC_PATCHLEVEL__: u32 = 1;
pub const __VERSION__: &'static [u8; 65usize] =
    b"7.3.1 20180622 (release) [ARM/embedded-7-branch revision 261907]\0";
pub const __ATOMIC_RELAXED: u32 = 0;
pub const __ATOMIC_SEQ_CST: u32 = 5;
pub const __ATOMIC_ACQUIRE: u32 = 2;
pub const __ATOMIC_RELEASE: u32 = 3;
pub const __ATOMIC_ACQ_REL: u32 = 4;
pub const __ATOMIC_CONSUME: u32 = 1;
pub const __OPTIMIZE__: u32 = 1;
pub const __FINITE_MATH_ONLY__: u32 = 0;
pub const __SIZEOF_INT__: u32 = 4;
pub const __SIZEOF_LONG__: u32 = 4;
pub const __SIZEOF_LONG_LONG__: u32 = 8;
pub const __SIZEOF_SHORT__: u32 = 2;
pub const __SIZEOF_FLOAT__: u32 = 4;
pub const __SIZEOF_DOUBLE__: u32 = 8;
pub const __SIZEOF_LONG_DOUBLE__: u32 = 8;
pub const __SIZEOF_SIZE_T__: u32 = 4;
pub const __CHAR_BIT__: u32 = 8;
pub const __BIGGEST_ALIGNMENT__: u32 = 8;
pub const __ORDER_LITTLE_ENDIAN__: u32 = 1234;
pub const __ORDER_BIG_ENDIAN__: u32 = 4321;
pub const __ORDER_PDP_ENDIAN__: u32 = 3412;
pub const __BYTE_ORDER__: u32 = 1234;
pub const __FLOAT_WORD_ORDER__: u32 = 1234;
pub const __SIZEOF_POINTER__: u32 = 4;
pub const __GXX_ABI_VERSION: u32 = 1011;
pub const __SCHAR_MAX__: u32 = 127;
pub const __SHRT_MAX__: u32 = 32767;
pub const __INT_MAX__: u32 = 2147483647;
pub const __LONG_MAX__: u32 = 2147483647;
pub const __LONG_LONG_MAX__: u64 = 9223372036854775807;
pub const __WCHAR_MAX__: u32 = 4294967295;
pub const __WCHAR_MIN__: u32 = 0;
pub const __WINT_MAX__: u32 = 4294967295;
pub const __WINT_MIN__: u32 = 0;
pub const __PTRDIFF_MAX__: u32 = 2147483647;
pub const __SIZE_MAX__: u32 = 4294967295;
pub const __SCHAR_WIDTH__: u32 = 8;
pub const __SHRT_WIDTH__: u32 = 16;
pub const __INT_WIDTH__: u32 = 32;
pub const __LONG_WIDTH__: u32 = 32;
pub const __LONG_LONG_WIDTH__: u32 = 64;
pub const __WCHAR_WIDTH__: u32 = 32;
pub const __WINT_WIDTH__: u32 = 32;
pub const __PTRDIFF_WIDTH__: u32 = 32;
pub const __SIZE_WIDTH__: u32 = 32;
pub const __INTMAX_MAX__: u64 = 9223372036854775807;
pub const __UINTMAX_MAX__: i32 = -1;
pub const __INTMAX_WIDTH__: u32 = 64;
pub const __SIG_ATOMIC_MAX__: u32 = 2147483647;
pub const __SIG_ATOMIC_MIN__: i32 = -2147483648;
pub const __SIG_ATOMIC_WIDTH__: u32 = 32;
pub const __INT8_MAX__: u32 = 127;
pub const __INT16_MAX__: u32 = 32767;
pub const __INT32_MAX__: u32 = 2147483647;
pub const __INT64_MAX__: u64 = 9223372036854775807;
pub const __UINT8_MAX__: u32 = 255;
pub const __UINT16_MAX__: u32 = 65535;
pub const __UINT32_MAX__: u32 = 4294967295;
pub const __UINT64_MAX__: i32 = -1;
pub const __INT_LEAST8_MAX__: u32 = 127;
pub const __INT_LEAST8_WIDTH__: u32 = 8;
pub const __INT_LEAST16_MAX__: u32 = 32767;
pub const __INT_LEAST16_WIDTH__: u32 = 16;
pub const __INT_LEAST32_MAX__: u32 = 2147483647;
pub const __INT_LEAST32_WIDTH__: u32 = 32;
pub const __INT_LEAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_LEAST64_WIDTH__: u32 = 64;
pub const __UINT_LEAST8_MAX__: u32 = 255;
pub const __UINT_LEAST16_MAX__: u32 = 65535;
pub const __UINT_LEAST32_MAX__: u32 = 4294967295;
pub const __UINT_LEAST64_MAX__: i32 = -1;
pub const __INT_FAST8_MAX__: u32 = 2147483647;
pub const __INT_FAST8_WIDTH__: u32 = 32;
pub const __INT_FAST16_MAX__: u32 = 2147483647;
pub const __INT_FAST16_WIDTH__: u32 = 32;
pub const __INT_FAST32_MAX__: u32 = 2147483647;
pub const __INT_FAST32_WIDTH__: u32 = 32;
pub const __INT_FAST64_MAX__: u64 = 9223372036854775807;
pub const __INT_FAST64_WIDTH__: u32 = 64;
pub const __UINT_FAST8_MAX__: u32 = 4294967295;
pub const __UINT_FAST16_MAX__: u32 = 4294967295;
pub const __UINT_FAST32_MAX__: u32 = 4294967295;
pub const __UINT_FAST64_MAX__: i32 = -1;
pub const __INTPTR_MAX__: u32 = 2147483647;
pub const __INTPTR_WIDTH__: u32 = 32;
pub const __UINTPTR_MAX__: u32 = 4294967295;
pub const __GCC_IEC_559: u32 = 0;
pub const __GCC_IEC_559_COMPLEX: u32 = 0;
pub const __FLT_EVAL_METHOD__: u32 = 0;
pub const __FLT_EVAL_METHOD_TS_18661_3__: u32 = 0;
pub const __DEC_EVAL_METHOD__: u32 = 2;
pub const __FLT_RADIX__: u32 = 2;
pub const __FLT_MANT_DIG__: u32 = 24;
pub const __FLT_DIG__: u32 = 6;
pub const __FLT_MIN_EXP__: i32 = -125;
pub const __FLT_MIN_10_EXP__: i32 = -37;
pub const __FLT_MAX_EXP__: u32 = 128;
pub const __FLT_MAX_10_EXP__: u32 = 38;
pub const __FLT_DECIMAL_DIG__: u32 = 9;
pub const __FLT_HAS_DENORM__: u32 = 1;
pub const __FLT_HAS_INFINITY__: u32 = 1;
pub const __FLT_HAS_QUIET_NAN__: u32 = 1;
pub const __DBL_MANT_DIG__: u32 = 53;
pub const __DBL_DIG__: u32 = 15;
pub const __DBL_MIN_EXP__: i32 = -1021;
pub const __DBL_MIN_10_EXP__: i32 = -307;
pub const __DBL_MAX_EXP__: u32 = 1024;
pub const __DBL_MAX_10_EXP__: u32 = 308;
pub const __DBL_DECIMAL_DIG__: u32 = 17;
pub const __DBL_HAS_DENORM__: u32 = 1;
pub const __DBL_HAS_INFINITY__: u32 = 1;
pub const __DBL_HAS_QUIET_NAN__: u32 = 1;
pub const __LDBL_MANT_DIG__: u32 = 53;
pub const __LDBL_DIG__: u32 = 15;
pub const __LDBL_MIN_EXP__: i32 = -1021;
pub const __LDBL_MIN_10_EXP__: i32 = -307;
pub const __LDBL_MAX_EXP__: u32 = 1024;
pub const __LDBL_MAX_10_EXP__: u32 = 308;
pub const __DECIMAL_DIG__: u32 = 17;
pub const __LDBL_DECIMAL_DIG__: u32 = 17;
pub const __LDBL_HAS_DENORM__: u32 = 1;
pub const __LDBL_HAS_INFINITY__: u32 = 1;
pub const __LDBL_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT32_MANT_DIG__: u32 = 24;
pub const __FLT32_DIG__: u32 = 6;
pub const __FLT32_MIN_EXP__: i32 = -125;
pub const __FLT32_MIN_10_EXP__: i32 = -37;
pub const __FLT32_MAX_EXP__: u32 = 128;
pub const __FLT32_MAX_10_EXP__: u32 = 38;
pub const __FLT32_DECIMAL_DIG__: u32 = 9;
pub const __FLT32_HAS_DENORM__: u32 = 1;
pub const __FLT32_HAS_INFINITY__: u32 = 1;
pub const __FLT32_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT64_MANT_DIG__: u32 = 53;
pub const __FLT64_DIG__: u32 = 15;
pub const __FLT64_MIN_EXP__: i32 = -1021;
pub const __FLT64_MIN_10_EXP__: i32 = -307;
pub const __FLT64_MAX_EXP__: u32 = 1024;
pub const __FLT64_MAX_10_EXP__: u32 = 308;
pub const __FLT64_DECIMAL_DIG__: u32 = 17;
pub const __FLT64_HAS_DENORM__: u32 = 1;
pub const __FLT64_HAS_INFINITY__: u32 = 1;
pub const __FLT64_HAS_QUIET_NAN__: u32 = 1;
pub const __FLT32X_MANT_DIG__: u32 = 53;
pub const __FLT32X_DIG__: u32 = 15;
pub const __FLT32X_MIN_EXP__: i32 = -1021;
pub const __FLT32X_MIN_10_EXP__: i32 = -307;
pub const __FLT32X_MAX_EXP__: u32 = 1024;
pub const __FLT32X_MAX_10_EXP__: u32 = 308;
pub const __FLT32X_DECIMAL_DIG__: u32 = 17;
pub const __FLT32X_HAS_DENORM__: u32 = 1;
pub const __FLT32X_HAS_INFINITY__: u32 = 1;
pub const __FLT32X_HAS_QUIET_NAN__: u32 = 1;
pub const __DEC32_MANT_DIG__: u32 = 7;
pub const __DEC32_MIN_EXP__: i32 = -94;
pub const __DEC32_MAX_EXP__: u32 = 97;
pub const __DEC64_MANT_DIG__: u32 = 16;
pub const __DEC64_MIN_EXP__: i32 = -382;
pub const __DEC64_MAX_EXP__: u32 = 385;
pub const __DEC128_MANT_DIG__: u32 = 34;
pub const __DEC128_MIN_EXP__: i32 = -6142;
pub const __DEC128_MAX_EXP__: u32 = 6145;
pub const __SFRACT_FBIT__: u32 = 7;
pub const __SFRACT_IBIT__: u32 = 0;
pub const __USFRACT_FBIT__: u32 = 8;
pub const __USFRACT_IBIT__: u32 = 0;
pub const __FRACT_FBIT__: u32 = 15;
pub const __FRACT_IBIT__: u32 = 0;
pub const __UFRACT_FBIT__: u32 = 16;
pub const __UFRACT_IBIT__: u32 = 0;
pub const __LFRACT_FBIT__: u32 = 31;
pub const __LFRACT_IBIT__: u32 = 0;
pub const __ULFRACT_FBIT__: u32 = 32;
pub const __ULFRACT_IBIT__: u32 = 0;
pub const __LLFRACT_FBIT__: u32 = 63;
pub const __LLFRACT_IBIT__: u32 = 0;
pub const __ULLFRACT_FBIT__: u32 = 64;
pub const __ULLFRACT_IBIT__: u32 = 0;
pub const __SACCUM_FBIT__: u32 = 7;
pub const __SACCUM_IBIT__: u32 = 8;
pub const __USACCUM_FBIT__: u32 = 8;
pub const __USACCUM_IBIT__: u32 = 8;
pub const __ACCUM_FBIT__: u32 = 15;
pub const __ACCUM_IBIT__: u32 = 16;
pub const __UACCUM_FBIT__: u32 = 16;
pub const __UACCUM_IBIT__: u32 = 16;
pub const __LACCUM_FBIT__: u32 = 31;
pub const __LACCUM_IBIT__: u32 = 32;
pub const __ULACCUM_FBIT__: u32 = 32;
pub const __ULACCUM_IBIT__: u32 = 32;
pub const __LLACCUM_FBIT__: u32 = 31;
pub const __LLACCUM_IBIT__: u32 = 32;
pub const __ULLACCUM_FBIT__: u32 = 32;
pub const __ULLACCUM_IBIT__: u32 = 32;
pub const __QQ_FBIT__: u32 = 7;
pub const __QQ_IBIT__: u32 = 0;
pub const __HQ_FBIT__: u32 = 15;
pub const __HQ_IBIT__: u32 = 0;
pub const __SQ_FBIT__: u32 = 31;
pub const __SQ_IBIT__: u32 = 0;
pub const __DQ_FBIT__: u32 = 63;
pub const __DQ_IBIT__: u32 = 0;
pub const __TQ_FBIT__: u32 = 127;
pub const __TQ_IBIT__: u32 = 0;
pub const __UQQ_FBIT__: u32 = 8;
pub const __UQQ_IBIT__: u32 = 0;
pub const __UHQ_FBIT__: u32 = 16;
pub const __UHQ_IBIT__: u32 = 0;
pub const __USQ_FBIT__: u32 = 32;
pub const __USQ_IBIT__: u32 = 0;
pub const __UDQ_FBIT__: u32 = 64;
pub const __UDQ_IBIT__: u32 = 0;
pub const __UTQ_FBIT__: u32 = 128;
pub const __UTQ_IBIT__: u32 = 0;
pub const __HA_FBIT__: u32 = 7;
pub const __HA_IBIT__: u32 = 8;
pub const __SA_FBIT__: u32 = 15;
pub const __SA_IBIT__: u32 = 16;
pub const __DA_FBIT__: u32 = 31;
pub const __DA_IBIT__: u32 = 32;
pub const __TA_FBIT__: u32 = 63;
pub const __TA_IBIT__: u32 = 64;
pub const __UHA_FBIT__: u32 = 8;
pub const __UHA_IBIT__: u32 = 8;
pub const __USA_FBIT__: u32 = 16;
pub const __USA_IBIT__: u32 = 16;
pub const __UDA_FBIT__: u32 = 32;
pub const __UDA_IBIT__: u32 = 32;
pub const __UTA_FBIT__: u32 = 64;
pub const __UTA_IBIT__: u32 = 64;
pub const __GNUC_STDC_INLINE__: u32 = 1;
pub const __CHAR_UNSIGNED__: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2: u32 = 1;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4: u32 = 1;
pub const __GCC_ATOMIC_BOOL_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR16_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_CHAR32_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_WCHAR_T_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_SHORT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_INT_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LONG_LOCK_FREE: u32 = 2;
pub const __GCC_ATOMIC_LLONG_LOCK_FREE: u32 = 1;
pub const __GCC_ATOMIC_TEST_AND_SET_TRUEVAL: u32 = 1;
pub const __GCC_ATOMIC_POINTER_LOCK_FREE: u32 = 2;
pub const __GCC_HAVE_DWARF2_CFI_ASM: u32 = 1;
pub const __PRAGMA_REDEFINE_EXTNAME: u32 = 1;
pub const __SIZEOF_WCHAR_T__: u32 = 4;
pub const __SIZEOF_WINT_T__: u32 = 4;
pub const __SIZEOF_PTRDIFF_T__: u32 = 4;
pub const __ARM_FEATURE_QBIT: u32 = 1;
pub const __ARM_FEATURE_SAT: u32 = 1;
pub const __ARM_FEATURE_UNALIGNED: u32 = 1;
pub const __ARM_32BIT_STATE: u32 = 1;
pub const __ARM_FEATURE_LDREX: u32 = 7;
pub const __ARM_FEATURE_CLZ: u32 = 1;
pub const __ARM_SIZEOF_MINIMAL_ENUM: u32 = 1;
pub const __ARM_SIZEOF_WCHAR_T: u32 = 4;
pub const __ARM_ARCH_PROFILE: u32 = 77;
pub const __arm__: u32 = 1;
pub const __ARM_ARCH: u32 = 7;
pub const __APCS_32__: u32 = 1;
pub const __thumb__: u32 = 1;
pub const __thumb2__: u32 = 1;
pub const __THUMBEL__: u32 = 1;
pub const __ARM_ARCH_ISA_THUMB: u32 = 2;
pub const __ARMEL__: u32 = 1;
pub const __SOFTFP__: u32 = 1;
pub const __VFP_FP__: u32 = 1;
pub const __THUMB_INTERWORK__: u32 = 1;
pub const __ARM_ARCH_7M__: u32 = 1;
pub const __ARM_PCS: u32 = 1;
pub const __ARM_EABI__: u32 = 1;
pub const __ARM_ARCH_EXT_IDIV__: u32 = 1;
pub const __ARM_FEATURE_IDIV: u32 = 1;
pub const __ARM_ASM_SYNTAX_UNIFIED__: u32 = 1;
pub const __ARM_FEATURE_COPROC: u32 = 15;
pub const __GXX_TYPEINFO_EQUALITY_INLINE: u32 = 0;
pub const __ELF__: u32 = 1;
pub const __USES_INITFINI__: u32 = 1;
pub const APP_my_sensor_app: u32 = 1;
pub const ARCH_cortex_m3: u32 = 1;
pub const BSP_bluepill: u32 = 1;
pub const FLOAT_SUPPORT: u32 = 1;
pub const MYNEWT: u32 = 1;
pub const STM32F103xB: u32 = 1;
pub const WITHOUT_OPEN_MEMSTREAM: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __STDC_LIMIT_MACROS: u32 = 1;
pub const MYNEWT_VAL_TINYCRYPT_SYSINIT_STAGE: u32 = 200;
pub const MYNEWT_VAL_TINYCRYPT_UECC_RNG_TRNG_DEV_NAME: &'static [u8; 5usize] = b"trng\0";
pub const MYNEWT_VAL_TINYCRYPT_UECC_RNG_USE_TRNG: u32 = 0;
pub const MYNEWT_VAL_CBORATTR_MAX_SIZE: u32 = 512;
pub const MYNEWT_VAL_STM32_FLASH_SIZE_KB: u32 = 128;
pub const MYNEWT_VAL_TIMER_0: u32 = 1;
pub const MYNEWT_VAL_TIMER_1: u32 = 0;
pub const MYNEWT_VAL_TIMER_2: u32 = 0;
pub const MYNEWT_VAL_UART_0: u32 = 1;
pub const MYNEWT_VAL_HAL_FLASH_VERIFY_BUF_SZ: u32 = 16;
pub const MYNEWT_VAL_HAL_FLASH_VERIFY_ERASES: u32 = 0;
pub const MYNEWT_VAL_HAL_FLASH_VERIFY_WRITES: u32 = 0;
pub const MYNEWT_VAL_I2C_0: u32 = 0;
pub const MYNEWT_VAL_MCU_FLASH_ERASED_VAL: u32 = 255;
pub const MYNEWT_VAL_MCU_FLASH_MIN_WRITE_SIZE: u32 = 2;
pub const MYNEWT_VAL_MCU_STM32F1: u32 = 1;
pub const MYNEWT_VAL_SPI_0_MASTER: u32 = 1;
pub const MYNEWT_VAL_SPI_0_SLAVE: u32 = 0;
pub const MYNEWT_VAL_SPI_1_MASTER: u32 = 0;
pub const MYNEWT_VAL_SPI_1_SLAVE: u32 = 0;
pub const MYNEWT_VAL_STM32_FLASH_IS_LINEAR: u32 = 1;
pub const MYNEWT_VAL_STM32_FLASH_SECTOR_SIZE: u32 = 1024;
pub const MYNEWT_VAL_STM32_HAL_I2C_HAS_CLOCKSPEED: u32 = 1;
pub const MYNEWT_VAL_STM32_HAL_SPI_HAS_FIFO: u32 = 0;
pub const MYNEWT_VAL_STM32_HAL_UART_HAS_SR: u32 = 1;
pub const MYNEWT_VAL_MATHLIB_SUPPORT: u32 = 0;
pub const MYNEWT_VAL_SENSOR_CLI: u32 = 0;
pub const MYNEWT_VAL_SENSOR_MAX_INTERRUPTS_PINS: u32 = 2;
pub const MYNEWT_VAL_SENSOR_NOTIF_EVENTS_MAX: u32 = 5;
pub const MYNEWT_VAL_SENSOR_OIC: u32 = 0;
pub const MYNEWT_VAL_SENSOR_OIC_OBS_RATE: u32 = 1000;
pub const MYNEWT_VAL_SENSOR_OIC_PERIODIC: u32 = 0;
pub const MYNEWT_VAL_SENSOR_POLL_TEST_LOG: u32 = 0;
pub const MYNEWT_VAL_SENSOR_SYSINIT_STAGE: u32 = 501;
pub const MYNEWT_VAL_ADXL345_OFB: u32 = 0;
pub const MYNEWT_VAL_BMA253_OFB: u32 = 0;
pub const MYNEWT_VAL_BMA2XX_OFB: u32 = 0;
pub const MYNEWT_VAL_BME280_OFB: u32 = 0;
pub const MYNEWT_VAL_BME680_OFB: u32 = 0;
pub const MYNEWT_VAL_BMP280_OFB: u32 = 0;
pub const MYNEWT_VAL_BNO055_OFB: u32 = 0;
pub const MYNEWT_VAL_DRV2605_OFB: u32 = 0;
pub const MYNEWT_VAL_LIS2DS12_OFB: u32 = 0;
pub const MYNEWT_VAL_LIS2DW12_OFB: u32 = 0;
pub const MYNEWT_VAL_LPS33HW_OFB: u32 = 0;
pub const MYNEWT_VAL_LPS33THW_OFB: u32 = 0;
pub const MYNEWT_VAL_LSM303DLHC_OFB: u32 = 0;
pub const MYNEWT_VAL_MPU6050_OFB: u32 = 0;
pub const MYNEWT_VAL_MS5837_OFB: u32 = 0;
pub const MYNEWT_VAL_MS5840_OFB: u32 = 0;
pub const MYNEWT_VAL_SENSOR_CREATOR_SYSINIT_STAGE: u32 = 500;
pub const MYNEWT_VAL_TCS34725_OFB: u32 = 0;
pub const MYNEWT_VAL_TSL2561_OFB: u32 = 0;
pub const MYNEWT_VAL_TSL2591_OFB: u32 = 0;
pub const MYNEWT_VAL_FLOAT_USER: u32 = 0;
pub const MYNEWT_VAL_MSYS_1_BLOCK_COUNT: u32 = 12;
pub const MYNEWT_VAL_MSYS_1_BLOCK_SIZE: u32 = 292;
pub const MYNEWT_VAL_MSYS_1_SANITY_MIN_COUNT: u32 = 0;
pub const MYNEWT_VAL_MSYS_2_BLOCK_COUNT: u32 = 0;
pub const MYNEWT_VAL_MSYS_2_BLOCK_SIZE: u32 = 0;
pub const MYNEWT_VAL_MSYS_2_SANITY_MIN_COUNT: u32 = 0;
pub const MYNEWT_VAL_MSYS_SANITY_TIMEOUT: u32 = 60000;
pub const MYNEWT_VAL_OS_CLI: u32 = 0;
pub const MYNEWT_VAL_OS_COREDUMP: u32 = 0;
pub const MYNEWT_VAL_OS_CPUTIME_FREQ: u32 = 1000000;
pub const MYNEWT_VAL_OS_CPUTIME_TIMER_NUM: u32 = 0;
pub const MYNEWT_VAL_OS_CRASH_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_OS_CRASH_LOG: u32 = 0;
pub const MYNEWT_VAL_OS_CRASH_RESTORE_REGS: u32 = 0;
pub const MYNEWT_VAL_OS_CRASH_STACKTRACE: u32 = 0;
pub const MYNEWT_VAL_OS_CTX_SW_STACK_CHECK: u32 = 0;
pub const MYNEWT_VAL_OS_CTX_SW_STACK_GUARD: u32 = 4;
pub const MYNEWT_VAL_OS_DEBUG_MODE: u32 = 0;
pub const MYNEWT_VAL_OS_EVENTQ_DEBUG: u32 = 0;
pub const MYNEWT_VAL_OS_EVENTQ_MONITOR: u32 = 0;
pub const MYNEWT_VAL_OS_IDLE_TICKLESS_MS_MAX: u32 = 600000;
pub const MYNEWT_VAL_OS_IDLE_TICKLESS_MS_MIN: u32 = 100;
pub const MYNEWT_VAL_OS_MAIN_STACK_SIZE: u32 = 1024;
pub const MYNEWT_VAL_OS_MAIN_TASK_PRIO: u32 = 127;
pub const MYNEWT_VAL_OS_MEMPOOL_CHECK: u32 = 0;
pub const MYNEWT_VAL_OS_MEMPOOL_GUARD: u32 = 0;
pub const MYNEWT_VAL_OS_MEMPOOL_POISON: u32 = 0;
pub const MYNEWT_VAL_OS_SCHEDULING: u32 = 1;
pub const MYNEWT_VAL_OS_SYSINIT_STAGE: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_CALLOUT: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_EVENTQ: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_MBUF: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_MEMPOOL: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_MUTEX: u32 = 0;
pub const MYNEWT_VAL_OS_SYSVIEW_TRACE_SEM: u32 = 0;
pub const MYNEWT_VAL_OS_TIME_DEBUG: u32 = 0;
pub const MYNEWT_VAL_OS_WATCHDOG_MONITOR: u32 = 0;
pub const MYNEWT_VAL_SANITY_INTERVAL: u32 = 15000;
pub const MYNEWT_VAL_WATCHDOG_INTERVAL: u32 = 30000;
pub const MYNEWT_VAL_BASELIBC_ASSERT_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_BASELIBC_PRESENT: u32 = 1;
pub const MYNEWT_VAL_OC_APP_RESOURCES: u32 = 2;
pub const MYNEWT_VAL_OC_CLIENT: u32 = 1;
pub const MYNEWT_VAL_OC_CLIENT_DISCOVERY_ENABLE: u32 = 0;
pub const MYNEWT_VAL_OC_COAP_RESPONSE_TIMEOUT: u32 = 4;
pub const MYNEWT_VAL_OC_CONCURRENT_REQUESTS: u32 = 2;
pub const MYNEWT_VAL_OC_CONN_EV_CB_CNT: u32 = 2;
pub const MYNEWT_VAL_OC_DEBUG: u32 = 0;
pub const MYNEWT_VAL_OC_LOGGING: u32 = 0;
pub const MYNEWT_VAL_OC_LORA_PORT: u32 = 187;
pub const MYNEWT_VAL_OC_MAX_PAYLOAD: u32 = 400;
pub const MYNEWT_VAL_OC_MAX_PAYLOAD_SIZE: u32 = 400;
pub const MYNEWT_VAL_OC_NUM_DEVICES: u32 = 1;
pub const MYNEWT_VAL_OC_NUM_REP_OBJECTS: u32 = 2;
pub const MYNEWT_VAL_OC_SEPARATE_RESPONSES: u32 = 1;
pub const MYNEWT_VAL_OC_SERVER: u32 = 0;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_GATT: u32 = 301;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_IP4: u32 = 301;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_IP6: u32 = 301;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_LORA: u32 = 301;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_MAIN: u32 = 300;
pub const MYNEWT_VAL_OC_SYSINIT_STAGE_SERIAL: u32 = 301;
pub const MYNEWT_VAL_OC_TRANSPORT_GATT: u32 = 0;
pub const MYNEWT_VAL_OC_TRANSPORT_IP: u32 = 0;
pub const MYNEWT_VAL_OC_TRANSPORT_IPV4: u32 = 0;
pub const MYNEWT_VAL_OC_TRANSPORT_IPV6: u32 = 0;
pub const MYNEWT_VAL_OC_TRANSPORT_LORA: u32 = 0;
pub const MYNEWT_VAL_OC_TRANSPORT_SERIAL: u32 = 0;
pub const MYNEWT_VAL_OC_TRANS_SECURITY: u32 = 0;
pub const MYNEWT_VAL_FLASH_MAP_MAX_AREAS: u32 = 10;
pub const MYNEWT_VAL_FLASH_MAP_SYSINIT_STAGE: u32 = 2;
pub const MYNEWT_VAL_MODLOG_CONSOLE_DFLT: u32 = 1;
pub const MYNEWT_VAL_MODLOG_LOG_MACROS: u32 = 0;
pub const MYNEWT_VAL_MODLOG_MAX_MAPPINGS: u32 = 16;
pub const MYNEWT_VAL_MODLOG_MAX_PRINTF_LEN: u32 = 128;
pub const MYNEWT_VAL_MODLOG_SYSINIT_STAGE: u32 = 100;
pub const MYNEWT_VAL_LOG_CONSOLE: u32 = 1;
pub const MYNEWT_VAL_LOG_FCB: u32 = 0;
pub const MYNEWT_VAL_LOG_FCB_SLOT1: u32 = 0;
pub const MYNEWT_VAL_LOG_LEVEL: u32 = 255;
pub const MYNEWT_VAL_MFG_LOG_MODULE: u32 = 128;
pub const MYNEWT_VAL_MFG_MAX_MMRS: u32 = 2;
pub const MYNEWT_VAL_MFG_SYSINIT_STAGE: u32 = 100;
pub const MYNEWT_VAL_DEBUG_PANIC_ENABLED: u32 = 1;
pub const MYNEWT_VAL_SYSDOWN_CONSTRAIN_DOWN: u32 = 1;
pub const MYNEWT_VAL_SYSDOWN_PANIC_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_SYSDOWN_PANIC_MESSAGE: u32 = 0;
pub const MYNEWT_VAL_SYSDOWN_TIMEOUT_MS: u32 = 10000;
pub const MYNEWT_VAL_SYSINIT_CONSTRAIN_INIT: u32 = 1;
pub const MYNEWT_VAL_SYSINIT_PANIC_FILE_LINE: u32 = 0;
pub const MYNEWT_VAL_SYSINIT_PANIC_MESSAGE: u32 = 0;
pub const MYNEWT_VAL_RWLOCK_DEBUG: u32 = 0;
pub const MYNEWT_VAL_ADC_1: u32 = 1;
pub const MYNEWT_VAL_ESP8266: u32 = 1;
pub const MYNEWT_VAL_HMAC_PRNG: u32 = 1;
pub const MYNEWT_VAL_NRF24L01: u32 = 1;
pub const MYNEWT_VAL_RAW_TEMP: u32 = 1;
pub const MYNEWT_VAL_REMOTE_SENSOR: u32 = 1;
pub const MYNEWT_VAL_SEMIHOSTING_CONSOLE: u32 = 1;
pub const MYNEWT_VAL_SENSOR_COAP: u32 = 1;
pub const MYNEWT_VAL_SENSOR_NETWORK: u32 = 1;
pub const MYNEWT_VAL_TEMP_STM32: u32 = 1;
pub const MYNEWT_VAL_TUTORIAL1: u32 = 0;
pub const MYNEWT_VAL_TUTORIAL2: u32 = 0;
pub const MYNEWT_VAL_TUTORIAL3: u32 = 1;
pub const MYNEWT_VAL_WIFI_GEOLOCATION: u32 = 0;
pub const MYNEWT_VAL_WIFI_PASSWORD: &'static [u8; 22usize] = b"my_password_is_secret\0";
pub const MYNEWT_VAL_WIFI_SSID: &'static [u8; 8usize] = b"my_ssid\0";
pub const MYNEWT_VAL_NRF24L01_AUTO_ACK: u32 = 0;
pub const MYNEWT_VAL_NRF24L01_AUTO_RETRANSMIT: u32 = 0;
pub const MYNEWT_VAL_NRF24L01_CRC_WIDTH: u32 = 8;
pub const MYNEWT_VAL_NRF24L01_DATA_RATE: u32 = 250;
pub const MYNEWT_VAL_NRF24L01_FREQ: u32 = 2476;
pub const MYNEWT_VAL_NRF24L01_POWER: u32 = 0;
pub const MYNEWT_VAL_NRF24L01_SPI_BAUDRATE: u32 = 200;
pub const MYNEWT_VAL_NRF24L01_SPI_NUM: u32 = 0;
pub const MYNEWT_VAL_NRF24L01_TX_SIZE: u32 = 12;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_1__DOUBLE: u32 = 0;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_1__FIELD: &'static [u8; 2usize] = b"t\0";
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_1__INT: u32 = 1;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_2__DOUBLE: u32 = 1;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_2__FIELD: &'static [u8; 3usize] = b"tf\0";
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_2__INT: u32 = 0;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_3__DOUBLE: u32 = 1;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_3__FIELD: &'static [u8; 2usize] = b"p\0";
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_3__INT: u32 = 0;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_4__DOUBLE: u32 = 1;
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_4__FIELD: &'static [u8; 2usize] = b"h\0";
pub const MYNEWT_VAL_REMOTE_SENSOR_TYPE_4__INT: u32 = 0;
pub const MYNEWT_VAL_CONSOLE_COMPAT: u32 = 1;
pub const MYNEWT_VAL_CONSOLE_DEFAULT_LOCK_TIMEOUT: u32 = 1000;
pub const MYNEWT_VAL_CONSOLE_ECHO: u32 = 0;
pub const MYNEWT_VAL_CONSOLE_HISTORY_SIZE: u32 = 0;
pub const MYNEWT_VAL_CONSOLE_INPUT: u32 = 0;
pub const MYNEWT_VAL_CONSOLE_MAX_INPUT_LEN: u32 = 256;
pub const MYNEWT_VAL_CONSOLE_SEMIHOSTING: u32 = 1;
pub const MYNEWT_VAL_CONSOLE_SEMIHOSTING_INPUT_POLL_INTERVAL_MAX: u32 = 250;
pub const MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_COUNT: u32 = 2;
pub const MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_DELAY_MS: u32 = 2;
pub const MYNEWT_VAL_CONSOLE_SEMIHOSTING_RETRY_IN_ISR: u32 = 0;
pub const MYNEWT_VAL_CONSOLE_SYSINIT_STAGE: u32 = 20;
pub const MYNEWT_VAL_CONSOLE_TICKS: u32 = 0;
pub const MYNEWT_VAL_COAP_CBOR_ENCODING: u32 = 1;
pub const MYNEWT_VAL_COAP_JSON_ENCODING: u32 = 1;
pub const MYNEWT_VAL_COAP_HOST: &'static [u8; 18usize] = b"coap.thethings.io\0";
pub const MYNEWT_VAL_COAP_PORT: u32 = 5683;
pub const MYNEWT_VAL_COAP_URI: &'static [u8; 54usize] =
    b"v2/things/IVRiBCcR6HPp_CcZIFfOZFxz_izni5xc_KO-kgSA2Y8\0";
pub const MYNEWT_VAL_COLLECTOR_NODE_ADDRESS: u64 = 517417236600;
pub const MYNEWT_VAL_SENSOR_NETWORK_ADDRESS: u32 = 3014964662;
pub const MYNEWT_VAL_SENSOR_NODE_OFFSET_1: u32 = 241;
pub const MYNEWT_VAL_SENSOR_NODE_OFFSET_2: u32 = 205;
pub const MYNEWT_VAL_SENSOR_NODE_OFFSET_3: u32 = 163;
pub const MYNEWT_VAL_SENSOR_NODE_OFFSET_4: u32 = 15;
pub const MYNEWT_VAL_SENSOR_NODE_OFFSET_5: u32 = 5;
pub const MYNEWT_VAL_APP_NAME: &'static [u8; 14usize] = b"my_sensor_app\0";
pub const MYNEWT_VAL_APP_my_sensor_app: u32 = 1;
pub const MYNEWT_VAL_ARCH_NAME: &'static [u8; 10usize] = b"cortex_m3\0";
pub const MYNEWT_VAL_ARCH_cortex_m3: u32 = 1;
pub const MYNEWT_VAL_BSP_NAME: &'static [u8; 9usize] = b"bluepill\0";
pub const MYNEWT_VAL_BSP_bluepill: u32 = 1;
pub const MYNEWT_VAL_NEWT_FEATURE_LOGCFG: u32 = 1;
pub const MYNEWT_VAL_NEWT_FEATURE_SYSDOWN: u32 = 1;
pub const MYNEWT_VAL_TARGET_NAME: &'static [u8; 19usize] = b"bluepill_my_sensor\0";
pub const MYNEWT_VAL_TARGET_bluepill_my_sensor: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const __NEWLIB_H__: u32 = 1;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &'static [u8; 6usize] = b"3.0.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 0;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const MB_LEN_MAX: u32 = 1;
pub const NL_ARGMAX: u32 = 32;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const ARG_MAX: u32 = 4096;
pub const PATH_MAX: u32 = 4096;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: u32 = 0;
pub const CHAR_MAX: u32 = 255;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const LONG_LONG_MAX: u64 = 9223372036854775807;
pub const ULONG_LONG_MAX: i32 = -1;
pub const __int20: u32 = 2;
pub const __INT8: &'static [u8; 3usize] = b"hh\0";
pub const __INT16: &'static [u8; 2usize] = b"h\0";
pub const __INT32: &'static [u8; 2usize] = b"l\0";
pub const __INT64: &'static [u8; 3usize] = b"ll\0";
pub const __FAST64: &'static [u8; 3usize] = b"ll\0";
pub const __LEAST8: &'static [u8; 3usize] = b"hh\0";
pub const __LEAST16: &'static [u8; 2usize] = b"h\0";
pub const __LEAST32: &'static [u8; 2usize] = b"l\0";
pub const __LEAST64: &'static [u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 4294967295;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const UINTMAX_MAX: i32 = -1;
pub const SIZE_MAX: u32 = 4294967295;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 4294967295;
pub const WINT_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const FLT_RADIX: u32 = 2;
pub const FLT_MANT_DIG: u32 = 24;
pub const DBL_MANT_DIG: u32 = 53;
pub const LDBL_MANT_DIG: u32 = 53;
pub const FLT_DIG: u32 = 6;
pub const DBL_DIG: u32 = 15;
pub const LDBL_DIG: u32 = 15;
pub const FLT_MIN_EXP: i32 = -125;
pub const DBL_MIN_EXP: i32 = -1021;
pub const LDBL_MIN_EXP: i32 = -1021;
pub const FLT_MIN_10_EXP: i32 = -37;
pub const DBL_MIN_10_EXP: i32 = -307;
pub const LDBL_MIN_10_EXP: i32 = -307;
pub const FLT_MAX_EXP: u32 = 128;
pub const DBL_MAX_EXP: u32 = 1024;
pub const LDBL_MAX_EXP: u32 = 1024;
pub const FLT_MAX_10_EXP: u32 = 38;
pub const DBL_MAX_10_EXP: u32 = 308;
pub const LDBL_MAX_10_EXP: u32 = 308;
pub const FLT_ROUNDS: u32 = 1;
pub const FLT_EVAL_METHOD: u32 = 0;
pub const DECIMAL_DIG: u32 = 17;
pub const FLT_DECIMAL_DIG: u32 = 9;
pub const DBL_DECIMAL_DIG: u32 = 17;
pub const LDBL_DECIMAL_DIG: u32 = 17;
pub const FLT_HAS_SUBNORM: u32 = 1;
pub const DBL_HAS_SUBNORM: u32 = 1;
pub const LDBL_HAS_SUBNORM: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __max_align_ll: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align_ld: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ll as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<max_align_t>())).__max_align_ld as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__max_align_ld)
        )
    );
}
extern "C" {
    pub fn __assert_func(
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        e: *const ::std::os::raw::c_char,
    );
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_long;
pub type __uint32_t = ::std::os::raw::c_ulong;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __int_least8_t = ::std::os::raw::c_schar;
pub type __uint_least8_t = ::std::os::raw::c_uchar;
pub type __int_least16_t = ::std::os::raw::c_short;
pub type __uint_least16_t = ::std::os::raw::c_ushort;
pub type __int_least32_t = ::std::os::raw::c_long;
pub type __uint_least32_t = ::std::os::raw::c_ulong;
pub type __int_least64_t = ::std::os::raw::c_longlong;
pub type __uint_least64_t = ::std::os::raw::c_ulonglong;
pub type __intmax_t = ::std::os::raw::c_longlong;
pub type __uintmax_t = ::std::os::raw::c_ulonglong;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __uintptr_t = ::std::os::raw::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_int;
pub type uint_fast8_t = ::std::os::raw::c_uint;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
extern "C" {
    pub fn memccpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memrchr(
        arg1: *const ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmem(
        arg1: *const ::std::os::raw::c_void,
        arg2: usize,
        arg3: *const ::std::os::raw::c_void,
        arg4: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memswap(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: usize,
    );
}
extern "C" {
    pub fn bzero(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn strcasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn index(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        arg1: *const ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strdup(arg1: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(arg1: *const ::std::os::raw::c_char, arg2: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(arg1: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn strnlen(arg1: *const ::std::os::raw::c_char, arg2: usize) -> usize;
}
extern "C" {
    pub fn strncat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcat(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strncmp(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlcpy(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> usize;
}
extern "C" {
    pub fn strpbrk(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsep(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> usize;
}
extern "C" {
    pub fn strstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnstr(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub type FILE = File;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File_methods {
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            instance: *mut FILE,
            bp: *const ::std::os::raw::c_char,
            n: usize,
        ) -> usize,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            instance: *mut FILE,
            bp: *mut ::std::os::raw::c_char,
            n: usize,
        ) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_File_methods() {
    assert_eq!(
        ::core::mem::size_of::<File_methods>(),
        16usize,
        concat!("Size of: ", stringify!(File_methods))
    );
    assert_eq!(
        ::core::mem::align_of::<File_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(File_methods))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File_methods>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(File_methods),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File_methods>())).read as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(File_methods),
            "::",
            stringify!(read)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    pub vmt: *const File_methods,
}
#[test]
fn bindgen_test_layout_File() {
    assert_eq!(
        ::core::mem::size_of::<File>(),
        8usize,
        concat!("Size of: ", stringify!(File))
    );
    assert_eq!(
        ::core::mem::align_of::<File>(),
        8usize,
        concat!("Alignment of ", stringify!(File))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File>())).vmt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(File), "::", stringify!(vmt))
    );
}
extern "C" {
    pub static stdin: *mut FILE;
}
extern "C" {
    pub static stdout: *mut FILE;
}
extern "C" {
    pub static stderr: *mut FILE;
}
extern "C" {
    pub fn fgets(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut errno: ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut ::std::os::raw::c_char,
        n: usize,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        n: usize,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemFile {
    pub file: File,
    pub buffer: *mut ::std::os::raw::c_char,
    pub bytes_written: usize,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_MemFile() {
    assert_eq!(
        ::core::mem::size_of::<MemFile>(),
        24usize,
        concat!("Size of: ", stringify!(MemFile))
    );
    assert_eq!(
        ::core::mem::align_of::<MemFile>(),
        8usize,
        concat!("Alignment of ", stringify!(MemFile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemFile>())).file as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MemFile),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemFile>())).buffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MemFile),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemFile>())).bytes_written as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MemFile),
            "::",
            stringify!(bytes_written)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<MemFile>())).size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MemFile),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn fmemopen_w(
        storage: *mut MemFile,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> *mut FILE;
}
pub const CborType_CborIntegerType: CborType = 0;
pub const CborType_CborByteStringType: CborType = 64;
pub const CborType_CborTextStringType: CborType = 96;
pub const CborType_CborArrayType: CborType = 128;
pub const CborType_CborMapType: CborType = 160;
pub const CborType_CborTagType: CborType = 192;
pub const CborType_CborSimpleType: CborType = 224;
pub const CborType_CborBooleanType: CborType = 245;
pub const CborType_CborNullType: CborType = 246;
pub const CborType_CborUndefinedType: CborType = 247;
pub const CborType_CborHalfFloatType: CborType = 249;
pub const CborType_CborFloatType: CborType = 250;
pub const CborType_CborDoubleType: CborType = 251;
pub const CborType_CborInvalidType: CborType = 255;
pub type CborType = u32;
pub type CborTag = u64;
pub const CborKnownTags_CborDateTimeStringTag: CborKnownTags = 0;
pub const CborKnownTags_CborUnixTime_tTag: CborKnownTags = 1;
pub const CborKnownTags_CborPositiveBignumTag: CborKnownTags = 2;
pub const CborKnownTags_CborNegativeBignumTag: CborKnownTags = 3;
pub const CborKnownTags_CborDecimalTag: CborKnownTags = 4;
pub const CborKnownTags_CborBigfloatTag: CborKnownTags = 5;
pub const CborKnownTags_CborExpectedBase64urlTag: CborKnownTags = 21;
pub const CborKnownTags_CborExpectedBase64Tag: CborKnownTags = 22;
pub const CborKnownTags_CborExpectedBase16Tag: CborKnownTags = 23;
pub const CborKnownTags_CborUriTag: CborKnownTags = 32;
pub const CborKnownTags_CborBase64urlTag: CborKnownTags = 33;
pub const CborKnownTags_CborBase64Tag: CborKnownTags = 34;
pub const CborKnownTags_CborRegularExpressionTag: CborKnownTags = 35;
pub const CborKnownTags_CborMimeMessageTag: CborKnownTags = 36;
pub const CborKnownTags_CborSignatureTag: CborKnownTags = 55799;
pub type CborKnownTags = u32;
pub const CborError_CborNoError: CborError = 0;
pub const CborError_CborUnknownError: CborError = 1;
pub const CborError_CborErrorUnknownLength: CborError = 2;
pub const CborError_CborErrorAdvancePastEOF: CborError = 3;
pub const CborError_CborErrorIO: CborError = 4;
pub const CborError_CborErrorGarbageAtEnd: CborError = 256;
pub const CborError_CborErrorUnexpectedEOF: CborError = 257;
pub const CborError_CborErrorUnexpectedBreak: CborError = 258;
pub const CborError_CborErrorUnknownType: CborError = 259;
pub const CborError_CborErrorIllegalType: CborError = 260;
pub const CborError_CborErrorIllegalNumber: CborError = 261;
pub const CborError_CborErrorIllegalSimpleType: CborError = 262;
pub const CborError_CborErrorUnknownSimpleType: CborError = 512;
pub const CborError_CborErrorUnknownTag: CborError = 513;
pub const CborError_CborErrorInappropriateTagForType: CborError = 514;
pub const CborError_CborErrorDuplicateObjectKeys: CborError = 515;
pub const CborError_CborErrorInvalidUtf8TextString: CborError = 516;
pub const CborError_CborErrorTooManyItems: CborError = 768;
pub const CborError_CborErrorTooFewItems: CborError = 769;
pub const CborError_CborErrorDataTooLarge: CborError = 1024;
pub const CborError_CborErrorNestingTooDeep: CborError = 1025;
pub const CborError_CborErrorUnsupportedType: CborError = 1026;
pub const CborError_CborErrorJsonObjectKeyIsAggregate: CborError = 1027;
pub const CborError_CborErrorJsonObjectKeyNotString: CborError = 1028;
pub const CborError_CborErrorJsonNotImplemented: CborError = 1029;
pub const CborError_CborErrorOutOfMemory: CborError = 2147483648;
pub const CborError_CborErrorInternalError: CborError = 4294967295;
pub type CborError = u32;
extern "C" {
    pub fn cbor_error_string(error: CborError) -> *const ::std::os::raw::c_char;
}
pub type cbor_encoder_write = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cbor_encoder_writer,
        data: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_encoder_writer {
    pub write: cbor_encoder_write,
    pub bytes_written: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_cbor_encoder_writer() {
    assert_eq!(
        ::core::mem::size_of::<cbor_encoder_writer>(),
        16usize,
        concat!("Size of: ", stringify!(cbor_encoder_writer))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_encoder_writer>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_encoder_writer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_encoder_writer>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_encoder_writer),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cbor_encoder_writer>())).bytes_written as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_encoder_writer),
            "::",
            stringify!(bytes_written)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_cbor_iovec() {
    assert_eq!(
        ::core::mem::size_of::<cbor_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(cbor_iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborEncoder {
    pub writer: *mut cbor_encoder_writer,
    pub writer_arg: *mut ::std::os::raw::c_void,
    pub added: usize,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CborEncoder() {
    assert_eq!(
        ::core::mem::size_of::<CborEncoder>(),
        24usize,
        concat!("Size of: ", stringify!(CborEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<CborEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(CborEncoder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).writer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).writer_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(writer_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).added as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(flags)
        )
    );
}
pub const CborIndefiniteLength: usize = 4294967295;
extern "C" {
    pub fn cbor_encoder_init(
        encoder: *mut CborEncoder,
        pwriter: *mut cbor_encoder_writer,
        flags: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn cbor_encode_uint(encoder: *mut CborEncoder, value: u64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_int(encoder: *mut CborEncoder, value: i64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_negative_int(encoder: *mut CborEncoder, absolute_value: u64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_simple_value(encoder: *mut CborEncoder, value: u8) -> CborError;
}
extern "C" {
    pub fn cbor_encode_tag(encoder: *mut CborEncoder, tag: CborTag) -> CborError;
}
extern "C" {
    pub fn cbor_encode_text_string(
        encoder: *mut CborEncoder,
        string: *const ::std::os::raw::c_char,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_byte_string(
        encoder: *mut CborEncoder,
        string: *const u8,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_byte_iovec(
        encoder: *mut CborEncoder,
        iov: *const cbor_iovec,
        iov_len: ::std::os::raw::c_int,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_floating_point(
        encoder: *mut CborEncoder,
        fpType: CborType,
        value: *const ::std::os::raw::c_void,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_array(
        encoder: *mut CborEncoder,
        arrayEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_map(
        encoder: *mut CborEncoder,
        mapEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_indef_byte_string(
        encoder: *mut CborEncoder,
        stringEncoder: *mut CborEncoder,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_close_container(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_close_container_checked(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
pub const CborParserIteratorFlags_CborIteratorFlag_IntegerValueTooLarge: CborParserIteratorFlags =
    1;
pub const CborParserIteratorFlags_CborIteratorFlag_NegativeInteger: CborParserIteratorFlags = 2;
pub const CborParserIteratorFlags_CborIteratorFlag_UnknownLength: CborParserIteratorFlags = 4;
pub const CborParserIteratorFlags_CborIteratorFlag_ContainerIsMap: CborParserIteratorFlags = 32;
pub type CborParserIteratorFlags = u32;
pub type cbor_reader_get8 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::std::os::raw::c_int) -> u8,
>;
pub type cbor_reader_get16 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::std::os::raw::c_int) -> u16,
>;
pub type cbor_reader_get32 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::std::os::raw::c_int) -> u32,
>;
pub type cbor_reader_get64 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::std::os::raw::c_int) -> u64,
>;
pub type cbor_memcmp = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::std::os::raw::c_char,
        offset: ::std::os::raw::c_int,
        len: usize,
    ) -> usize,
>;
pub type cbor_memcpy = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::std::os::raw::c_char,
        offset: ::std::os::raw::c_int,
        len: usize,
    ) -> usize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_decoder_reader {
    pub get8: cbor_reader_get8,
    pub get16: cbor_reader_get16,
    pub get32: cbor_reader_get32,
    pub get64: cbor_reader_get64,
    pub cmp: cbor_memcmp,
    pub cpy: cbor_memcpy,
    pub message_size: usize,
}
#[test]
fn bindgen_test_layout_cbor_decoder_reader() {
    assert_eq!(
        ::core::mem::size_of::<cbor_decoder_reader>(),
        56usize,
        concat!("Size of: ", stringify!(cbor_decoder_reader))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_decoder_reader>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_decoder_reader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get32 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get64 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).cmp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).cpy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(cpy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cbor_decoder_reader>())).message_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(message_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborParser {
    pub d: *mut cbor_decoder_reader,
    pub end: ::std::os::raw::c_int,
    pub flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_CborParser() {
    assert_eq!(
        ::core::mem::size_of::<CborParser>(),
        16usize,
        concat!("Size of: ", stringify!(CborParser))
    );
    assert_eq!(
        ::core::mem::align_of::<CborParser>(),
        8usize,
        concat!("Alignment of ", stringify!(CborParser))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborValue {
    pub parser: *const CborParser,
    pub offset: ::std::os::raw::c_int,
    pub remaining: u32,
    pub extra: u16,
    pub type_: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_CborValue() {
    assert_eq!(
        ::core::mem::size_of::<CborValue>(),
        32usize,
        concat!("Size of: ", stringify!(CborValue))
    );
    assert_eq!(
        ::core::mem::align_of::<CborValue>(),
        8usize,
        concat!("Alignment of ", stringify!(CborValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).parser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).remaining as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).type_ as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).flags as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn cbor_parser_init(
        d: *mut cbor_decoder_reader,
        flags: ::std::os::raw::c_int,
        parser: *mut CborParser,
        it: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance_fixed(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_enter_container(it: *const CborValue, recursed: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_leave_container(it: *mut CborValue, recursed: *const CborValue) -> CborError;
}
extern "C" {
    pub fn _cbor_value_decode_int64_internal(value: *const CborValue) -> u64;
}
extern "C" {
    pub fn cbor_value_get_int64_checked(value: *const CborValue, result: *mut i64) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_int_checked(
        value: *const CborValue,
        result: *mut ::std::os::raw::c_int,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_skip_tag(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn _cbor_value_copy_string(
        value: *const CborValue,
        buffer: *mut ::std::os::raw::c_void,
        buflen: *mut usize,
        next: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn _cbor_value_dup_string(
        value: *const CborValue,
        buffer: *mut *mut ::std::os::raw::c_void,
        buflen: *mut usize,
        next: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_calculate_string_length(
        value: *const CborValue,
        length: *mut usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_text_string_equals(
        value: *const CborValue,
        string: *const ::std::os::raw::c_char,
        result: *mut bool,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_map_find_value(
        map: *const CborValue,
        string: *const ::std::os::raw::c_char,
        element: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_half_float(
        value: *const CborValue,
        result: *mut ::std::os::raw::c_void,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_to_pretty_advance(out: *mut FILE, value: *mut CborValue) -> CborError;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mgmt_cbuf {
    pub parser: CborParser,
    pub encoder: CborEncoder,
    pub it: CborValue,
}
#[test]
fn bindgen_test_layout_mgmt_cbuf() {
    assert_eq!(
        ::core::mem::size_of::<mgmt_cbuf>(),
        72usize,
        concat!("Size of: ", stringify!(mgmt_cbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<mgmt_cbuf>(),
        8usize,
        concat!("Alignment of ", stringify!(mgmt_cbuf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mgmt_cbuf>())).parser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mgmt_cbuf),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mgmt_cbuf>())).encoder as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mgmt_cbuf),
            "::",
            stringify!(encoder)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mgmt_cbuf>())).it as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mgmt_cbuf),
            "::",
            stringify!(it)
        )
    );
}
pub const CborMajorTypes_UnsignedIntegerType: CborMajorTypes = 0;
pub const CborMajorTypes_NegativeIntegerType: CborMajorTypes = 1;
pub const CborMajorTypes_ByteStringType: CborMajorTypes = 2;
pub const CborMajorTypes_TextStringType: CborMajorTypes = 3;
pub const CborMajorTypes_ArrayType: CborMajorTypes = 4;
pub const CborMajorTypes_MapType: CborMajorTypes = 5;
pub const CborMajorTypes_TagType: CborMajorTypes = 6;
pub const CborMajorTypes_SimpleTypesType: CborMajorTypes = 7;
pub type CborMajorTypes = u32;
pub const CborSimpleTypes_FalseValue: CborSimpleTypes = 20;
pub const CborSimpleTypes_TrueValue: CborSimpleTypes = 21;
pub const CborSimpleTypes_NullValue: CborSimpleTypes = 22;
pub const CborSimpleTypes_UndefinedValue: CborSimpleTypes = 23;
pub const CborSimpleTypes_SimpleTypeInNextByte: CborSimpleTypes = 24;
pub const CborSimpleTypes_HalfPrecisionFloat: CborSimpleTypes = 25;
pub const CborSimpleTypes_SinglePrecisionFloat: CborSimpleTypes = 26;
pub const CborSimpleTypes_DoublePrecisionFloat: CborSimpleTypes = 27;
pub const CborSimpleTypes_Break: CborSimpleTypes = 31;
pub type CborSimpleTypes = u32;
pub const SmallValueBitLength: _bindgen_ty_1 = 5;
pub const SmallValueMask: _bindgen_ty_1 = 31;
pub const Value8Bit: _bindgen_ty_1 = 24;
pub const Value16Bit: _bindgen_ty_1 = 25;
pub const Value32Bit: _bindgen_ty_1 = 26;
pub const Value64Bit: _bindgen_ty_1 = 27;
pub const IndefiniteLength: _bindgen_ty_1 = 31;
pub const MajorTypeShift: _bindgen_ty_1 = 5;
pub const MajorTypeMask: _bindgen_ty_1 = 4294967264;
pub const BreakByte: _bindgen_ty_1 = 255;
pub type _bindgen_ty_1 = u32;
extern "C" {
    pub fn atoi(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn atof(str: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn strtod(
        nptr: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn free(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn malloc(arg1: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(arg1: usize, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(arg1: *mut ::std::os::raw::c_void, arg2: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn add_malloc_block(arg1: *mut ::std::os::raw::c_void, arg2: usize);
}
extern "C" {
    pub fn get_malloc_memory_status(arg1: *mut usize, arg2: *mut usize);
}
pub type malloc_lock_t = ::core::option::Option<unsafe extern "C" fn() -> bool>;
pub type malloc_unlock_t = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn set_malloc_locking(arg1: malloc_lock_t, arg2: malloc_unlock_t);
}
extern "C" {
    pub fn strtol(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type __comparefunc_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: usize,
        arg4: usize,
        arg5: __comparefunc_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        arg1: *mut ::std::os::raw::c_void,
        arg2: usize,
        arg3: usize,
        arg4: __comparefunc_t,
    );
}
extern "C" {
    pub fn jrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn seed48(arg1: *const ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn srand48(arg1: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _exit(s: ::std::os::raw::c_int);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
