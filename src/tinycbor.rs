/* automatically generated by rust-bindgen */

pub type __uint8_t = ::cty::c_uchar;
pub type __uint16_t = ::cty::c_ushort;
pub type __uint32_t = ::cty::c_ulong;
pub type __int64_t = ::cty::c_longlong;
pub type __uint64_t = ::cty::c_ulonglong;
pub type __uintptr_t = ::cty::c_uint;
pub type FILE = File;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File_methods {
    pub write: ::core::option::Option<
        unsafe extern "C" fn(instance: *mut FILE, bp: *const ::cty::c_char, n: usize) -> usize,
    >,
    pub read: ::core::option::Option<
        unsafe extern "C" fn(instance: *mut FILE, bp: *mut ::cty::c_char, n: usize) -> usize,
    >,
}
#[test]
fn bindgen_test_layout_File_methods() {
    assert_eq!(
        ::core::mem::size_of::<File_methods>(),
        16usize,
        concat!("Size of: ", stringify!(File_methods))
    );
    assert_eq!(
        ::core::mem::align_of::<File_methods>(),
        8usize,
        concat!("Alignment of ", stringify!(File_methods))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File_methods>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(File_methods),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File_methods>())).read as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(File_methods),
            "::",
            stringify!(read)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct File {
    pub vmt: *const File_methods,
}
#[test]
fn bindgen_test_layout_File() {
    assert_eq!(
        ::core::mem::size_of::<File>(),
        8usize,
        concat!("Size of: ", stringify!(File))
    );
    assert_eq!(
        ::core::mem::align_of::<File>(),
        8usize,
        concat!("Alignment of ", stringify!(File))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<File>())).vmt as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(File), "::", stringify!(vmt))
    );
}
pub const CborType_CborIntegerType: CborType = 0;
pub const CborType_CborByteStringType: CborType = 64;
pub const CborType_CborTextStringType: CborType = 96;
pub const CborType_CborArrayType: CborType = 128;
pub const CborType_CborMapType: CborType = 160;
pub const CborType_CborTagType: CborType = 192;
pub const CborType_CborSimpleType: CborType = 224;
pub const CborType_CborBooleanType: CborType = 245;
pub const CborType_CborNullType: CborType = 246;
pub const CborType_CborUndefinedType: CborType = 247;
pub const CborType_CborHalfFloatType: CborType = 249;
pub const CborType_CborFloatType: CborType = 250;
pub const CborType_CborDoubleType: CborType = 251;
pub const CborType_CborInvalidType: CborType = 255;
pub type CborType = u32;
pub type CborTag = u64;
pub const CborKnownTags_CborDateTimeStringTag: CborKnownTags = 0;
pub const CborKnownTags_CborUnixTime_tTag: CborKnownTags = 1;
pub const CborKnownTags_CborPositiveBignumTag: CborKnownTags = 2;
pub const CborKnownTags_CborNegativeBignumTag: CborKnownTags = 3;
pub const CborKnownTags_CborDecimalTag: CborKnownTags = 4;
pub const CborKnownTags_CborBigfloatTag: CborKnownTags = 5;
pub const CborKnownTags_CborExpectedBase64urlTag: CborKnownTags = 21;
pub const CborKnownTags_CborExpectedBase64Tag: CborKnownTags = 22;
pub const CborKnownTags_CborExpectedBase16Tag: CborKnownTags = 23;
pub const CborKnownTags_CborUriTag: CborKnownTags = 32;
pub const CborKnownTags_CborBase64urlTag: CborKnownTags = 33;
pub const CborKnownTags_CborBase64Tag: CborKnownTags = 34;
pub const CborKnownTags_CborRegularExpressionTag: CborKnownTags = 35;
pub const CborKnownTags_CborMimeMessageTag: CborKnownTags = 36;
pub const CborKnownTags_CborSignatureTag: CborKnownTags = 55799;
pub type CborKnownTags = u32;
pub const CborError_CborNoError: CborError = 0;
pub const CborError_CborUnknownError: CborError = 1;
pub const CborError_CborErrorUnknownLength: CborError = 2;
pub const CborError_CborErrorAdvancePastEOF: CborError = 3;
pub const CborError_CborErrorIO: CborError = 4;
pub const CborError_CborErrorGarbageAtEnd: CborError = 256;
pub const CborError_CborErrorUnexpectedEOF: CborError = 257;
pub const CborError_CborErrorUnexpectedBreak: CborError = 258;
pub const CborError_CborErrorUnknownType: CborError = 259;
pub const CborError_CborErrorIllegalType: CborError = 260;
pub const CborError_CborErrorIllegalNumber: CborError = 261;
pub const CborError_CborErrorIllegalSimpleType: CborError = 262;
pub const CborError_CborErrorUnknownSimpleType: CborError = 512;
pub const CborError_CborErrorUnknownTag: CborError = 513;
pub const CborError_CborErrorInappropriateTagForType: CborError = 514;
pub const CborError_CborErrorDuplicateObjectKeys: CborError = 515;
pub const CborError_CborErrorInvalidUtf8TextString: CborError = 516;
pub const CborError_CborErrorTooManyItems: CborError = 768;
pub const CborError_CborErrorTooFewItems: CborError = 769;
pub const CborError_CborErrorDataTooLarge: CborError = 1024;
pub const CborError_CborErrorNestingTooDeep: CborError = 1025;
pub const CborError_CborErrorUnsupportedType: CborError = 1026;
pub const CborError_CborErrorJsonObjectKeyIsAggregate: CborError = 1027;
pub const CborError_CborErrorJsonObjectKeyNotString: CborError = 1028;
pub const CborError_CborErrorJsonNotImplemented: CborError = 1029;
pub const CborError_CborErrorOutOfMemory: CborError = 2147483648;
pub const CborError_CborErrorInternalError: CborError = 4294967295;
pub type CborError = u32;
extern "C" {
    pub fn cbor_error_string(error: CborError) -> *const ::cty::c_char;
}
pub type cbor_encoder_write = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cbor_encoder_writer,
        data: *const ::cty::c_char,
        len: ::cty::c_int,
    ) -> ::cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_encoder_writer {
    pub write: cbor_encoder_write,
    pub bytes_written: ::cty::c_int,
}
#[test]
fn bindgen_test_layout_cbor_encoder_writer() {
    assert_eq!(
        ::core::mem::size_of::<cbor_encoder_writer>(),
        16usize,
        concat!("Size of: ", stringify!(cbor_encoder_writer))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_encoder_writer>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_encoder_writer))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_encoder_writer>())).write as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_encoder_writer),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cbor_encoder_writer>())).bytes_written as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_encoder_writer),
            "::",
            stringify!(bytes_written)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_iovec {
    pub iov_base: *mut ::cty::c_void,
    pub iov_len: usize,
}
#[test]
fn bindgen_test_layout_cbor_iovec() {
    assert_eq!(
        ::core::mem::size_of::<cbor_iovec>(),
        16usize,
        concat!("Size of: ", stringify!(cbor_iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborEncoder {
    pub writer: *mut cbor_encoder_writer,
    pub writer_arg: *mut ::cty::c_void,
    pub added: usize,
    pub flags: ::cty::c_int,
}
#[test]
fn bindgen_test_layout_CborEncoder() {
    assert_eq!(
        ::core::mem::size_of::<CborEncoder>(),
        24usize,
        concat!("Size of: ", stringify!(CborEncoder))
    );
    assert_eq!(
        ::core::mem::align_of::<CborEncoder>(),
        8usize,
        concat!("Alignment of ", stringify!(CborEncoder))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).writer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(writer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).writer_arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(writer_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).added as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(added)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborEncoder>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CborEncoder),
            "::",
            stringify!(flags)
        )
    );
}
pub const CborIndefiniteLength: usize = 4294967295;
extern "C" {
    pub fn cbor_encoder_init(
        encoder: *mut CborEncoder,
        pwriter: *mut cbor_encoder_writer,
        flags: ::cty::c_int,
    );
}
extern "C" {
    pub fn cbor_encode_uint(encoder: *mut CborEncoder, value: u64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_int(encoder: *mut CborEncoder, value: i64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_negative_int(encoder: *mut CborEncoder, absolute_value: u64) -> CborError;
}
extern "C" {
    pub fn cbor_encode_simple_value(encoder: *mut CborEncoder, value: u8) -> CborError;
}
extern "C" {
    pub fn cbor_encode_tag(encoder: *mut CborEncoder, tag: CborTag) -> CborError;
}
extern "C" {
    pub fn cbor_encode_text_string(
        encoder: *mut CborEncoder,
        string: *const ::cty::c_char,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_byte_string(
        encoder: *mut CborEncoder,
        string: *const u8,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_byte_iovec(
        encoder: *mut CborEncoder,
        iov: *const cbor_iovec,
        iov_len: ::cty::c_int,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encode_floating_point(
        encoder: *mut CborEncoder,
        fpType: CborType,
        value: *const ::cty::c_void,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_array(
        encoder: *mut CborEncoder,
        arrayEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_map(
        encoder: *mut CborEncoder,
        mapEncoder: *mut CborEncoder,
        length: usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_create_indef_byte_string(
        encoder: *mut CborEncoder,
        stringEncoder: *mut CborEncoder,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_close_container(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_encoder_close_container_checked(
        encoder: *mut CborEncoder,
        containerEncoder: *const CborEncoder,
    ) -> CborError;
}
pub const CborParserIteratorFlags_CborIteratorFlag_IntegerValueTooLarge: CborParserIteratorFlags =
    1;
pub const CborParserIteratorFlags_CborIteratorFlag_NegativeInteger: CborParserIteratorFlags = 2;
pub const CborParserIteratorFlags_CborIteratorFlag_UnknownLength: CborParserIteratorFlags = 4;
pub const CborParserIteratorFlags_CborIteratorFlag_ContainerIsMap: CborParserIteratorFlags = 32;
pub type CborParserIteratorFlags = u32;
pub type cbor_reader_get8 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u8,
>;
pub type cbor_reader_get16 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u16,
>;
pub type cbor_reader_get32 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u32,
>;
pub type cbor_reader_get64 = ::core::option::Option<
    unsafe extern "C" fn(d: *mut cbor_decoder_reader, offset: ::cty::c_int) -> u64,
>;
pub type cbor_memcmp = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::cty::c_char,
        offset: ::cty::c_int,
        len: usize,
    ) -> usize,
>;
pub type cbor_memcpy = ::core::option::Option<
    unsafe extern "C" fn(
        d: *mut cbor_decoder_reader,
        buf: *mut ::cty::c_char,
        offset: ::cty::c_int,
        len: usize,
    ) -> usize,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbor_decoder_reader {
    pub get8: cbor_reader_get8,
    pub get16: cbor_reader_get16,
    pub get32: cbor_reader_get32,
    pub get64: cbor_reader_get64,
    pub cmp: cbor_memcmp,
    pub cpy: cbor_memcpy,
    pub message_size: usize,
}
#[test]
fn bindgen_test_layout_cbor_decoder_reader() {
    assert_eq!(
        ::core::mem::size_of::<cbor_decoder_reader>(),
        56usize,
        concat!("Size of: ", stringify!(cbor_decoder_reader))
    );
    assert_eq!(
        ::core::mem::align_of::<cbor_decoder_reader>(),
        8usize,
        concat!("Alignment of ", stringify!(cbor_decoder_reader))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get16 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get16)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get32 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get32)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).get64 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(get64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).cmp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(cmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cbor_decoder_reader>())).cpy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(cpy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cbor_decoder_reader>())).message_size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cbor_decoder_reader),
            "::",
            stringify!(message_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborParser {
    pub d: *mut cbor_decoder_reader,
    pub end: ::cty::c_int,
    pub flags: ::cty::c_int,
}
#[test]
fn bindgen_test_layout_CborParser() {
    assert_eq!(
        ::core::mem::size_of::<CborParser>(),
        16usize,
        concat!("Size of: ", stringify!(CborParser))
    );
    assert_eq!(
        ::core::mem::align_of::<CborParser>(),
        8usize,
        concat!("Alignment of ", stringify!(CborParser))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborParser>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CborParser),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CborValue {
    pub parser: *const CborParser,
    pub offset: ::cty::c_int,
    pub remaining: u32,
    pub extra: u16,
    pub type_: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_CborValue() {
    assert_eq!(
        ::core::mem::size_of::<CborValue>(),
        32usize,
        concat!("Size of: ", stringify!(CborValue))
    );
    assert_eq!(
        ::core::mem::align_of::<CborValue>(),
        8usize,
        concat!("Alignment of ", stringify!(CborValue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).parser as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(parser)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).remaining as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(remaining)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).type_ as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<CborValue>())).flags as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(CborValue),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn cbor_parser_init(
        d: *mut cbor_decoder_reader,
        flags: ::cty::c_int,
        parser: *mut CborParser,
        it: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance_fixed(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_advance(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_enter_container(it: *const CborValue, recursed: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_leave_container(it: *mut CborValue, recursed: *const CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_int64_checked(value: *const CborValue, result: *mut i64) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_int_checked(
        value: *const CborValue,
        result: *mut ::cty::c_int,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_skip_tag(it: *mut CborValue) -> CborError;
}
extern "C" {
    pub fn cbor_value_calculate_string_length(
        value: *const CborValue,
        length: *mut usize,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_text_string_equals(
        value: *const CborValue,
        string: *const ::cty::c_char,
        result: *mut bool,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_map_find_value(
        map: *const CborValue,
        string: *const ::cty::c_char,
        element: *mut CborValue,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_get_half_float(
        value: *const CborValue,
        result: *mut ::cty::c_void,
    ) -> CborError;
}
extern "C" {
    pub fn cbor_value_to_pretty_advance(out: *mut FILE, value: *mut CborValue) -> CborError;
}
pub const CborMajorTypes_UnsignedIntegerType: CborMajorTypes = 0;
pub const CborMajorTypes_NegativeIntegerType: CborMajorTypes = 1;
pub const CborMajorTypes_ByteStringType: CborMajorTypes = 2;
pub const CborMajorTypes_TextStringType: CborMajorTypes = 3;
pub const CborMajorTypes_ArrayType: CborMajorTypes = 4;
pub const CborMajorTypes_MapType: CborMajorTypes = 5;
pub const CborMajorTypes_TagType: CborMajorTypes = 6;
pub const CborMajorTypes_SimpleTypesType: CborMajorTypes = 7;
pub type CborMajorTypes = u32;
pub const CborSimpleTypes_FalseValue: CborSimpleTypes = 20;
pub const CborSimpleTypes_TrueValue: CborSimpleTypes = 21;
pub const CborSimpleTypes_NullValue: CborSimpleTypes = 22;
pub const CborSimpleTypes_UndefinedValue: CborSimpleTypes = 23;
pub const CborSimpleTypes_SimpleTypeInNextByte: CborSimpleTypes = 24;
pub const CborSimpleTypes_HalfPrecisionFloat: CborSimpleTypes = 25;
pub const CborSimpleTypes_SinglePrecisionFloat: CborSimpleTypes = 26;
pub const CborSimpleTypes_DoublePrecisionFloat: CborSimpleTypes = 27;
pub const CborSimpleTypes_Break: CborSimpleTypes = 31;
pub type CborSimpleTypes = u32;
